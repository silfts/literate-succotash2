<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Безопасность GraphQL API</title>
  <style>
    :root {
      --bg-color: #1e1e1e;
      --text-color: #e0e0e0;
      --heading-color: #4fd1c5;
      --code-bg: #2d2d2d;
      --code-text: #ffffff;
      --accent: #00bcd4;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: "Segoe UI", sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 40px auto;
      padding: 20px;
    }

    h1, h2, h3 {
      color: var(--heading-color);
    }

    img {
      display: block;
      margin: 15px auto;
      max-width: 100%;
      height: auto;
      border: 1px solid #555;
      border-radius: 6px;
    }

    code {
      background-color: var(--code-bg);
      color: var(--code-text);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: Consolas, monospace;
    }

    pre {
      background-color: var(--code-bg);
      color: var(--code-text);
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: Consolas, monospace;
      font-size: 15px;
      margin: 20px 0;
    }

    ul {
      padding-left: 20px;
    }

    a {
      color: var(--accent);
    }

    blockquote {
      border-left: 4px solid #4fd1c5;
      padding-left: 15px;
      margin: 1em 0;
      color: #ccc;
    }
  </style>
</head>
<body>

  <h1>Безопасность и эксплуатация GraphQL</h1>
  <p>
   GraphQL – это язык запроса API, который позволяет клиентам гибко запрашивать только нужные данные. В отличие от REST API , GraphQL позволяет объединить несколько запросов в один, что делает его более эффективным. Однако его гибкость и универсальность создают серьезные проблемы безопасности, если API не настроен должным образом. В этой статье рассмотрены основные моменты воздействия на GraphQL , методы защиты и инструменты тестирования безопасности.
  </p>

  <h2>Архитектура GraphQL и отличие от REST</h2>
  <p>
    GraphQL и REST – два варианта построения API, но они различаются принципами работы.
  </p>
  <img src="1.jpg" alt="GraphQL vs REST">

  <p>
    REST (передача репрезентативного состояния) строится на основе количества эндпоинтов, каждый из которых отвечает за текущий ресурс (например, /players, /teams, /matches). Клиент делает несколько запросов к разным эндпоинтам, чтобы получить нужные данные. Это может привести к:

резервной передачи данных ( over-fetching), когда клиент получает больше информации, чем необходимо;

недостаточная передача данных ( under-fetching), когда клиенту приходится делать несколько запросов, чтобы собрать всю необходимую информацию. 
GraphQL использует единый конечный пункт ( /graphql), который принимает запросы на получение только исходных данных. Клиент может задать вопросы по конкретным вопросам, избегая проблем over-fetchingи under-fetchingт. д. Однако такой подход порождает новые риски:

Возможность удаления скрытых данных, если схема API не настроена должным образом;

уязвимость к механизмам рекурсивным запросам, которые могут перезагружать сервер.
  </p>

  <h2>Основная концепция GraphQL</h2>
  <p>Схема : Определить типы данных, доступные в API, и отношения между ними. Схема контракта между клиентом и сервером, описывающая, какие запросы можно выполнить и какие данные можно получить.

Типы : основные схемы построения блоков. Включают скалярные типы (например, Int, String, Boolean) и объектные типы, которые могут содержать несколько полей различных типов.

Запросы : используются для чтения данных. Клиент определяет структуру запроса, и сервер получает данные точно в таком же формате.

Мутации : используются для изменения данных (создания, обновления, удаления).

Подписки : разрешить клиенту получать обновления в мгновение ока при просмотре данных на расстоянии.

Пример схемы GraphQL:</p>

  <pre><code>type Author {
  id: ID!
  name: String!
  books: [Book]
}

type Book {
  id: ID!
  title: String!
  author: Author
}</code></pre>

  <p>
    В данном методе используются методы и методы, Authorа Book также запросы на получение списков авторов, книг и книг по ID. Мутация addBook Позволяет добавить новую книгу с именем и идентификатором автора.
  </p>

  <h2>Основные уязвимости в GraphQL</h2>

  <h3>1. Инспекция схемы (Introspection Attack)</h3>
  <p>
В GraphQL встроена возможность самоанализа (самоанализа), которая позволяет клиенту запрашивать API модели, включая все доступные типы, запросы и мутации. Хоть это и удобно, но может стать уязвимым, если не отключить его заранее. Злоумышленник, получивший доступ к шаблону, может использовать его для поиска скрытых API и уязвимых эндпоинтов.

Запрос самоанализа в GraphQL Playground:
  </p>
  <pre><code>{
  __schema {
    types {
      name
      fields {
        name
      }
    }
  }
}</code></pre>

  <h3>2. GraphQL-инъекции</h3>
  <p>
    GraphQL-инъекции похожи на традиционные SQL-инъекции. Всегда, когда входные данные пользователя обрабатываются без проверок и используются для выполнения внутреннего запроса.

Пример GraphQL-инъекции:
  </p>
  <pre><code>{
  user(id: "1 OR 1=1") {
    username
  }
}</code></pre>
  <p>
    В случае уязвимости API оно может вернуть список всех пользователей вместо одного. Что может привести к утечке конфиденциальной информации.

Другой вариант лечения – внедрение в мутации:
  </p>
 <pre><code>{
mutation {
  updateUser(id: "1", username: "hacker") {
    username
  }
}
}</code></pre>
  <p>
    Если сервер ранее не получил доступа к правам, атакующий может изменить данные других пользователей.
  </p>
  <h3>3. DDoS-атаки через сложный запрос</h3>
  <p>
    GraphQL позволяет создавать вложенные запросы, которые могут быть использованы злоумышленниками для перегрузки сервера. Если сервер не ограничивает ввод рекурсивных запросов, злоумышленник может создать бесконечную рекурсию и вызвать отказ в обслуживании.

Пример атаки:
  </p>
  <pre><code>{
  user {
    friends {
      friends {
        friends {
          username
        }
      }
    }
  }
}</code></pre>
<p>
  Если сервер не настроен на ограничение вложенных запросов, он будет обрабатывать их до полного исчерпания ресурсов.
</p>
  
  <h2>Методы и способы защиты GraphQL API</h2>
  <ul>
    <li>Ограничение доступа к запросам интроспекции : интроспекция Позволяет студентам получать информацию о шаблоне API. В производственной среде рекомендуется отключить интроспекцию, чтобы злоумышленники не могли получить информацию о ходе API.

</li>
    <li>Проверка входных данных : необходимо проверять и ограничивать входные данные, чтобы предотвратить инъекции и другие действия. Например, можно использовать директивы для проверки данных на уровне схемы.</li>
    <li>Ограничение глубины и сложности запроса : чтобы предотвратить действие типа «отказ в обслуживании» (DoS) с помощью изменения или простых рекурсивных запросов, следует сохранить ограничения на общую структуру и сложность запроса.

</li>
    <li>Ограничение частоты запросов (Rate Limiting): для предотвращения обработки уязвимых мутаций или брутфорс-атак рекомендуется ограничить количество запросов от одного клиента в течение текущего периода времени. Это можно реализовать с помощью специальных плагинов или промежуточного программного обеспечения.

</li>
    <li>Использование безопасного транспортного протокола : при использовании HTTP для запросов и мутаций необходимо применять HTTPS для шифрования данных и защиты их от перехвата.

</li>
    <li>Аутентификация и авторизация : необходимо внедрить надежные механизмы аутентификации и авторизации, чтобы гарантировать, что только авторизованные пользователи могут выполнять рабочие операции или получать доступ к данным наблюдения.</li>
  </ul>

  <h3>Пример реализации ограничений на запросы к Node.js с использованием graphql-depth-limit:</h3>
  <pre><code>const express = require('express');
const { graphqlHTTP } = require('express-graphql');
const { makeExecutableSchema } = require('@graphql-tools/schema');
const depthLimit = require('graphql-depth-limit');

const typeDefs = `
  type Query {
    hello: String
  }
`;

const resolvers = {
  Query: {
    hello: () => 'Hello world!',
  },
};

const schema = makeExecutableSchema({ typeDefs, resolvers });

const app = express();

app.use(
  '/graphql',
  graphqlHTTP({
    schema: schema,
    validationRules: [depthLimit(5)],
  })
);

app.listen(4000, () => {
  console.log('Server is running on http://localhost:4000/graphql');
});</code></pre>
<p>
  В данном примере используется промежуточное программное обеспечение graphql-depth-limit для ограничения глубины запроса до 5 уровней, которое помогает предотвратить воздействие с использованием дополнительного запроса.

Реализация современной меры безопасности позволит защитить GraphQL API от указанных уязвимостей и обеспечить стабильную и безопасную работу сервиса.
</p>
  <h2>Инструменты для тестирования безопасности GraphQL</h2>

  <h3>GraphQLmap</h3>
  <p>GraphQLmap – автоматизированный инструмент для тестирования GraphQL API на уязвимости.</p>
  <img src="2.jpg" alt="GraphQLmap интерфейс">

  <h3>GraphQL Voyager</h3>
  <p>GraphQL Voyager – инструмент для визуализации API схем и поиска уязвимостей.</p>
  <img src="3.jpg" alt="GraphQL Voyager пример">

  <h3>InQL (Burp Suite Plugin)</h3>
  <p>InQL (Burp Suite Plugin) – расширение Burp Suite для анализа GraphQL API и обнаружения скрытых эндпоинтов.</p>
  <img src="4.jpg" alt="InQL для Burp Suite">

  <h2>Заключение</h2>
  <p>
    GraphQL — гибкий инструмент для построения API, но требует строгих мер безопасности. Используй ограничения, валидацию, аутентификацию и тестовые инструменты, чтобы предотвратить возможные уязвимости.
  </p>

</body>
</html>
